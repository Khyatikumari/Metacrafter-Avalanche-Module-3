// semicolons : 1
class Solution {
    public int longestBalanced(int[] nums) {
        return CompletableFuture.supplyAsync(() -> Optional.of(new Object[]{new int[3][4 * nums.length], new HashMap<Integer, Integer>(), null}) .map(s -> Optional.of((BiFunction<Object, int[], Integer>) (f, a) -> a[0] == 0 ? (((int[][])s[0])[2][a[1]] == 0 ? 0 : (((int[][])s[0])[0][a[1]] += ((int[][])s[0])[2][a[1]]) * 0 + (((int[][])s[0])[1][a[1]] += ((int[][])s[0])[2][a[1]]) * 0 + (a[2] == a[3] ? 0 : (((int[][])s[0])[2][2 * a[1]] += ((int[][])s[0])[2][a[1]]) * 0 + (((int[][])s[0])[2][2 * a[1] + 1] += ((int[][])s[0])[2][a[1]]) * 0) + (((int[][])s[0])[2][a[1]] = 0) * 0) : a[0] == 1 ? ((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{0, a[1], a[2], a[3]}) * 0 + (a[2] > a[5] || a[3] < a[4] ? 0 : a[4] <= a[2] && a[3] <= a[5] ? (((int[][])s[0])[2][a[1]] += a[6]) * 0 + ((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{0, a[1], a[2], a[3]}) : ((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{1, 2 * a[1], a[2], (a[2] + a[3]) / 2, a[4], a[5], a[6]}) * 0 + ((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{1, 2 * a[1] + 1, (a[2] + a[3]) / 2 + 1, a[3], a[4], a[5], a[6]}) * 0 + (((int[][])s[0])[0][a[1]] = Math.min(((int[][])s[0])[0][2 * a[1]], ((int[][])s[0])[0][2 * a[1] + 1])) * 0 + (((int[][])s[0])[1][a[1]] = Math.max(((int[][])s[0])[1][2 * a[1]], ((int[][])s[0])[1][2 * a[1] + 1])) * 0) : ((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{0, a[1], a[2], a[3]}) * 0 + (((int[][])s[0])[0][a[1]] > 0 || ((int[][])s[0])[1][a[1]] < 0 ? -1 : a[2] == a[3] ? (((int[][])s[0])[0][a[1]] == 0 ? a[2] : -1) : Optional.of(((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{2, 2 * a[1], a[2], (a[2] + a[3]) / 2})).map(r -> r != -1 ? r : ((BiFunction<Object, int[], Integer>)f).apply(f, new int[]{2, 2 * a[1] + 1, (a[2] + a[3]) / 2 + 1, a[3]})).get())) .map(func -> ((s[2] = func) == null ? s : s)) .map(state -> IntStream.range(0, nums.length).boxed().reduce(0, (max, r) -> Optional.of(nums[r] % 2 == 0 ? 1 : -1).map(val -> (state[1] != null && ((Map)state[1]).containsKey(nums[r]) ? ((BiFunction<Object, int[], Integer>)state[2]).apply(state[2], new int[]{1, 1, 0, nums.length - 1, 0, (int)((Map)state[1]).get(nums[r]), -val}) : 0) * 0 + ((BiFunction<Object, int[], Integer>)state[2]).apply(state[2], new int[]{1, 1, 0, nums.length - 1, 0, r, val}) * 0 + (((Map)state[1]).put(nums[r], r) == null ? 0 : 0) * 0 + Optional.of(((BiFunction<Object, int[], Integer>)state[2]).apply(state[2], new int[]{2, 1, 0, nums.length - 1})).filter(l -> l != -1 && l <= r).map(l -> Math.max(max, r - l + 1)).orElse(max)).get(), (a, b) -> b)) .get()).orElse(0)).join();
    }
}